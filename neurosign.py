# -*- coding: utf-8 -*-
"""NeuroSigns.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cp1qwev7byIgv0Rwvaux7sazJ9Dm9b0x
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.svm import SVC
from sklearn.preprocessing import StandardScaler
from sklearn.ensemble import RandomForestClassifier
from sklearn.tree import DecisionTreeClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report, confusion_matrix
from sklearn.cluster import KMeans
from sklearn.metrics import silhouette_score

pf_1=pd.read_csv('/content/EEG dataset.csv')     #EEG electrodes...
pf_1.head()

pf_1.info()

pf_1.describe()

pf_1.shape

col=pf_1.select_dtypes(include='number').columns
col

X=pf_1.drop('eyeDetection',axis=1)
y=pf_1['eyeDetection']
for col in X:
  plt.hist(pf_1[pf_1['eyeDetection']==1][col], color='red',label='eyemovments-detected',density='True')
  plt.hist(pf_1[pf_1['eyeDetection']==0][col],color='blue',label='no-eyemovments-detected',density='True')
  plt.xlabel(col)
  plt.ylabel('frequancy of {col}')
  plt.legend()
  plt.show()

import seaborn as sns
import matplotlib.pyplot as plt

# Assuming 'col' should contain the numerical columns
col = pf_1.select_dtypes(include='number').columns

for column_name in col:
  sns.boxplot(x=pf_1[column_name]) # Pass the column data to boxplot using x=
  plt.title(column_name)
  plt.xlabel(column_name)
  plt.ylabel('count')
  plt.show()

import seaborn as sns
import matplotlib.pyplot as plt

# Assuming 'col' should contain the numerical columns
col = pf_1.select_dtypes(include='number').columns

for column_name in col:
  sns.boxplot(x=pf_1[column_name]) # Pass the column data to boxplot using x=
  plt.title(column_name)
  plt.xlabel(column_name)
  plt.ylabel('count')
  plt.show()

pf_1.isnull().sum()

pf_1.duplicated().sum()

from scipy import stats

z_scores = np.abs(stats.zscore(pf_1.select_dtypes(include=[np.number])))
outliers = np.where(z_scores > 3)
print(outliers)

Q1 = pf_1.select_dtypes(include=[np.number]).quantile(0.25)
Q3 = pf_1.select_dtypes(include=[np.number]).quantile(0.75)
IQR = Q3 - Q1


outliers = ((pf_1.select_dtypes(include=[np.number]) < (Q1 - 1.5 * IQR)) | (pf_1.select_dtypes(include=[np.number]) > (Q3 + 1.5 * IQR)))
print(outliers)

s_1=pf_1.corr()
plt.figure(figsize=(10,10))
sns.heatmap(s_1,annot=True)
plt.show()

pf_2=pd.read_csv('/content/EEG_data.csv')        #EEG ALPHA,BETA,GAMMA
pf_2.head()

pf_2.info()

pf_2.describe()

pf_2.shape

import matplotlib.pyplot as plt

X = pf_2.drop(['predefinedlabel', 'user-definedlabeln'], axis=1)
y = pf_2[['predefinedlabel', 'user-definedlabeln']]

for col in X:

  data_red = pf_2[(pf_2['predefinedlabel'] == 1) & (pf_2['user-definedlabeln'] == 1)][col]
  data_blue = pf_2[(pf_2['predefinedlabel'] == 0) & (pf_2['user-definedlabeln'] == 0)][col]

  plt.hist(data_red, color='red', density=True)
  plt.hist(data_blue, color='blue', density=True)
  plt.xlabel(col)
  plt.ylabel(f'Frequency of {col}')
  plt.legend()
  plt.show()

s2=pf_2.corr()
plt.figure(figsize=(10,10))
sns.heatmap(s2,annot=True)
plt.show()

from scipy import stats

zscores = np.abs(stats.zscore(pf_2.select_dtypes(include=[np.number])))
outliers2 = np.where(zscores > 3)
print(outliers2)

q1 = pf_2.quantile(0.25)
q3 = pf_2.quantile(0.75)
iqr = q3 - q1


outliers2 = ((pf_2.select_dtypes(include=[np.number]) < (q1 - 1.5 * iqr)) | (pf_2.select_dtypes(include=[np.number]) > (q3 + 1.5 * iqr)))
print(outliers2)

col2=pf_2.select_dtypes(include='number').columns
col2

"""### EYE DETECTION

"""

X_train_eye, X_test_eye, y_train_eye, y_test_eye = train_test_split(X, y, test_size=0.3, random_state=42)
print("dimension of train data : ", X_train_eye.shape, y_train_eye.shape)
print("dimension of test data : ", X_test_eye.shape, y_test_eye.shape)

scaler=StandardScaler()
X_train_eye=scaler.fit_transform(X_train_eye)
X_test_eye=scaler.transform(X_test_eye)
model=RandomForestClassifier(n_estimators=100,random_state=42)
model.fit(X_train_eye,y_train_eye)
y_per_eye=model.predict(X_test_eye)
print(classification_report(y_test_eye,y_per_eye))
plt.scatter(y_test_eye,y_per_eye)
plt.legend()
plt.show()



"""###STRESS DETECTION

"""

pf_2['beta-alpha-ratio'] = (pf_2['Beta1'] + pf_2['Beta2']) / (pf_2['Alpha1'] + pf_2['Alpha2'])

def asssign_stress_level(row):
  if row['beta-alpha-ratio']>1.5:
    return 2
  elif row['beta-alpha-ratio']<1.5 and row['beta-alpha-ratio']>1:
    return 1
  elif row['beta-alpha-ratio']<1:
    return 0

pf_2['stress_level']=pf_2.apply(asssign_stress_level,axis=1)
print(pf_2['stress_level'])

X_stress = pf_2[['Beta1', 'Beta2', 'Alpha1', 'Alpha2']]
y_stress = pf_2['stress_level']

X_stress_train, X_stress_test, y_stress_train, y_stresss_test = train_test_split(X_stress, y_stress, test_size=0.2, random_state=42)

model = DecisionTreeClassifier(random_state=42)
model.fit(X_stress_train, y_stress_train)
y_pred_stress = model.predict(X_stress_test)

print(classification_report(y_stresss_test, y_pred_stress))

decision_tree_accuracy = accuracy_score(y_stresss_test, y_pred_stress)
print(f"Decision Tree Accuracy: {decision_tree_accuracy * 100:.2f}%")

from scikitlaarn import LinearRegrssion
from sklearn.metrics import mean_squared_error, r2_score
X_train,Y_train,X_test,Y_test=split
X_stress = pf_2[['Beta1', 'Beta2', 'Alpha1', 'Alpha2']]
y_stress = pf_2['stress_level']
model=fit(X_stress,y_stress)
y_pred_stress=model.predict(X_stress_test)

"""ADHD dETECTION"""

X_adhd = pf_2[['Mediation', 'Attention']]
scaler = StandardScaler()
X_adhd_scaled = scaler.fit_transform(X_adhd)

kmeans = KMeans(n_clusters=2, random_state=42)
pf_2['Cluster'] = kmeans.fit_predict(X_adhd_scaled)

plt.scatter(pf_2['Mediation'], pf_2['Attention'], c=pf_2['Cluster'], cmap='viridis')
plt.xlabel( 'Mediation')
plt.ylabel('Attention')
plt.title('K-Means Clustering of  Mediation  and Attention')
plt.show()

pf_2['ADHD_Prediction'] = np.where(pf_2['Cluster'] == 0, 1, 0)

print(pf_2['ADHD_Prediction'])
adhd_accuracy = accuracy_score(y_stresss_test, y_pred_stress)
print(f"Decision Tree Accuracy: {adhd_accuracy * 100:.2f}%")

"""### STOKE DETECTION"""

X_stroke = pf_2[['Attention', 'Mediation', 'Delta', 'Theta', 'Alpha1', 'Alpha2']]

scaler = StandardScaler()
X_stroke_scaled = scaler.fit_transform(X_stroke)

kmeans = KMeans(n_clusters=2, random_state=42)
pf_2['Cluster'] = kmeans.fit_predict(X_stroke_scaled)

plt.scatter(pf_2['Attention'], pf_2['Mediation'], c=pf_2['Cluster'], cmap='viridis')
plt.xlabel('Attention')
plt.ylabel('Mediation')
plt.title('K-Means Clustering of Attention and Mediation')
plt.show()


pf_2['Stroke_Prediction'] = np.where(pf_2['Cluster'] == 0, 1, 0)

print("Stroke Prediction for each instance:")
print(pf_2[['Attention', 'Mediation', 'Cluster', 'Stroke_Prediction']])

print("\nCluster Centers (Attention, Mediation, Delta, Theta, Alpha):")
print(scaler.inverse_transform(kmeans.cluster_centers_))

stroke_accuracy = accuracy_score(y_stresss_test, y_pred_stress)
print(f"Decision Tree Accuracy: {stroke_accuracy * 100:.2f}%")
